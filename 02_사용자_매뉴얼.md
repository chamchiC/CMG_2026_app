# 사용자 매뉴얼 - 명령어 및 데이터 형식

이 문서는 CMG_2026 시스템을 사용하는 방법을 설명합니다. HMI 명령어 사용법과 텔레메트리 데이터 형식을 포함합니다.

## 📋 목차

0. [처음 사용하는 분께 (포트 구분)](#0-처음-사용하는-분께-포트-구분)
1. [HMI 명령어 사용법](#1-hmi-명령어-사용법)
2. [텔레메트리 데이터 형식](#2-텔레메트리-데이터-형식)
3. [실제 사용 예시](#3-실제-사용-예시)
4. [안전 주의사항](#4-안전-주의사항)

---

## 0. 처음 사용하는 분께 (포트 구분)

시스템에는 **두 가지 시리얼 포트**가 있습니다. 용도가 다르므로 연결 전에 확인하세요.

| 구분 | 포트 | 연결 방법 | 용도 |
|------|------|-----------|------|
| **디버그** | UART0 (USB) | ESP32를 PC에 **USB 케이블**로 연결 | `printf`, `ESP_LOG` 등 **로그만** 출력. 명령 전송 불가. |
| **HMI + 텔레메트리** | UART1 (GPIO 18/17) | **USB-시리얼 어댑터**(CH340, CP2102 등)로 GPIO 18(TX), 17(RX), GND 연결 | **명령 전송/수신**, 바이너리 텔레메트리(100Hz), 상태/LOG 수신. |

**요약:**
- **디버그 로그만 보려면** → ESP32를 USB로 PC에 연결한 뒤 시리얼 모니터(115200)로 확인.
- **명령어(R, S1, B1 등)를 보내거나 그래프/상태를 받으려면** → **별도 USB-시리얼 어댑터**를 구해서 **GPIO 18(TX), 17(RX), GND**에 연결하고, 해당 COM 포트를 115200으로 열어 사용하세요.
- UART1 한 포트에서 **바이너리 데이터**와 **ASCII 명령/응답**이 함께 나오므로, 수신 프로그램에서 `0xAA 0x55`로 바이너리 패킷을 구분하고, 줄 단위 텍스트는 ASCII로 처리하면 됩니다.

자세한 핀 연결은 [`03_하드웨어_가이드.md`](03_하드웨어_가이드.md)를 참조하세요.

---

## 1. HMI 명령어 사용법

### 1.1 통신 설정

**연결 정보 (HMI 명령을 보내려면 반드시 UART1 사용):**
- **포트**: **UART1** (GPIO 18 TX, 17 RX). USB가 아닌 **USB-시리얼 어댑터**로 GPIO 18/17에 연결해야 합니다. 바이너리 텔레메트리와 ASCII 명령/응답이 **같은 포트**에서 혼용됩니다.
- **통신 속도**: **115200 baud**
- **데이터 비트**: 8
- **패리티**: 없음
- **정지 비트**: 1
- **명령 종료**: 줄바꿈 문자 (`\n` 또는 Enter)

**시리얼 터미널 설정:**
- PuTTY, Tera Term, Arduino Serial Monitor 등 사용 가능
- **Baud Rate: 115200**
- Line Ending: LF 또는 CR+LF

### 1.2 휠 모터 제어 명령어

#### RPM 설정: `R<값>`

목표 RPM을 설정합니다. (구동 시작 전에 설정해야 합니다)

**사용법:**
```
R1000    ← 1000 RPM으로 설정
R500     ← 500 RPM으로 설정
R0       ← 0 RPM (정지)
```

**설명:**
- RPM 값은 0 이상의 정수입니다
- 음수는 자동으로 0으로 변환됩니다
- 이 명령어는 RPM만 설정하며, 모터는 구동하지 않습니다
- 실제 구동을 시작하려면 `S1` 명령어를 사용하세요

**응답 예시:**
```
LOG: Target RPM set to 1000
```

---

#### 구동 시작/정지: `S<0 또는 1>`

휠 모터의 구동을 시작하거나 정지합니다.

**사용법:**
```
S1    ← 구동 시작 (설정된 RPM으로 구동)
S0    ← 정지 (점진적으로 정지)
```

**설명:**
- `S1`: 구동 시작
  - 이전에 `R` 명령어로 설정한 RPM으로 모터가 구동됩니다
  - 비상 정지 상태에서는 구동할 수 없습니다 (먼저 `X` 명령어로 해제 필요)
- `S0`: 정지
  - 모터가 점진적으로 정지합니다 (약 5초 소요)
  - 비상 정지 상태도 자동으로 해제됩니다

**응답 예시:**
```
LOG: Wheel START (Target RPM: 1000)
LOG: Wheel STOP
```

**주의사항:**
- 비상 정지 상태에서는 `S1` 명령어가 작동하지 않습니다
- 비상 정지를 해제하려면 `X` 명령어를 먼저 사용하세요

---

#### 비상 정지: `E` 또는 `EMER`

모터를 즉시 정지시킵니다. (안전상 가장 중요한 명령어)

**사용법:**
```
E      ← 비상 정지 (간단한 명령)
EMER   ← 비상 정지 (긴 명령)
```

**설명:**
- 모터가 **즉시 정지**합니다 (점진적 정지 없음)
- PWM이 0%로 즉시 설정됩니다
- 비상 정지 상태가 활성화되어 추가 구동이 차단됩니다
- 비상 정지를 해제하려면 `X` 명령어를 사용해야 합니다

**응답 예시:**
```
LOG: EMERGENCY STOP!
```

**⚠️ 중요:**
- 비상 상황 발생 시 즉시 이 명령어를 사용하세요
- 비상 정지 후에는 반드시 `X` 명령어로 해제해야 다시 구동할 수 있습니다

---

#### 비상 정지 해제: `X` 또는 `XRESET`

비상 정지 상태를 해제합니다.

**사용법:**
```
X         ← 비상 정지 해제 (간단한 명령)
XRESET    ← 비상 정지 해제 (긴 명령)
```

**응답 예시:**
```
LOG: Emergency stop RESET
```

---

#### 상태 조회: `?`

현재 시스템 상태를 조회합니다.

**사용법:**
```
?
```

**응답 예시:**
```
STATUS: State=1, TargetRPM=1000, Wheel1_RPM=998, Wheel1_PWM=65.5%, 
        Wheel2_RPM=1002, Wheel2_PWM=66.2%, Gimbal=15.2, Roll=2.0, Pitch=-0.45
```

**응답 필드 설명:**
- `State`: 휠 모터 상태 (0=정지, 1=구동, 2=비상정지)
- `TargetRPM`: 목표 RPM
- `Wheel1_RPM`, `Wheel2_RPM`: 실제 RPM
- `Wheel1_PWM`, `Wheel2_PWM`: PWM 값 (%)
- `Gimbal`: 현재 짐벌 각도 (도)
- `Roll`, `Pitch`: 센서 각도 (도)

---

### 1.3 짐벌 제어 명령어

#### 목표 각도 설정: `A<각도>`

짐벌의 목표 각도를 설정합니다. (수동 모드)

**사용법:**
```
A30      ← 30도로 설정
A-45     ← -45도로 설정
A0       ← 0도 (중간 위치)
```

**설명:**
- 각도 범위: -135도 ~ +135도
- 범위를 벗어나면 자동으로 제한됩니다
- 밸런싱 모드가 자동으로 해제됩니다

**응답 예시:**
```
LOG: Gimbal angle set to 30.0
```

---

#### PID 게인 설정: `P<Kp>,<Ki>,<Kd>`

짐벌 모터의 PID 게인을 설정합니다. (현재는 사용하지 않음, 호환성 유지)

**사용법:**
```
P80,10,5    ← Kp=80, Ki=10, Kd=5
```

**참고:** 서보 모터는 내부 PID 제어를 사용하므로 이 명령어는 실제로는 작동하지 않습니다.

---

### 1.4 밸런싱 제어 명령어

#### 밸런싱 모드: `B<0 또는 1>`

밸런싱 모드를 켜거나 끕니다.

**사용법:**
```
B1    ← 밸런싱 모드 시작
B0    ← 밸런싱 모드 종료
```

**설명:**
- `B1`: 밸런싱 모드 시작
  - 짐벌 각도가 0도로 리셋됩니다
  - PID 제어가 활성화되어 자동으로 밸런싱합니다
- `B0`: 밸런싱 모드 종료
  - 수동 모드로 전환됩니다

**응답 예시:**
```
LOG: Balancing START
LOG: Balancing STOP
```

---

#### 밸런싱 PID 게인 설정: `K<Kp>,<Ki>,<Kd>,<Washout>`

밸런싱 제어의 PID 게인과 워시아웃 게인을 설정합니다.

**사용법:**
```
K5.0,0.1,0.5,0.05    ← Kp=5.0, Ki=0.1, Kd=0.5, Washout=0.05
K5.0,0.1,0.5        ← Washout 생략 시 기본값 사용
```

**파라미터 설명:**
- `Kp`: P 게인 (비례 항) - 기본값: 5.0
- `Ki`: I 게인 (적분 항) - 기본값: 0.0
- `Kd`: D 게인 (미분 항) - 기본값: 0.5
- `Washout`: 워시아웃 게인 (짐벌 리셋 강도) - 기본값: 0.05

**응답 예시:**
```
LOG: Balancing PID Kp=5.00, Ki=0.100, Kd=0.50, Washout=0.050
```

---

#### 휠 제어 PID 게인 설정: `WK<Kp>,<Ki>,<Kd>`

휠 모터 제어의 PID 게인을 설정합니다.

**사용법:**
```
WK0.005,0.000001,0.0001    ← Kp=0.005, Ki=0.000001, Kd=0.0001
```

**파라미터 설명:**
- `Kp`: P 게인 - 기본값: 0.005
- `Ki`: I 게인 - 기본값: 0.0
- `Kd`: D 게인 - 기본값: 0.0

**응답 예시:**
```
LOG: Wheel PID Kp=0.0050, Ki=0.000001, Kd=0.0001
```

---

#### 워시아웃 게인 설정: `W<값>`

워시아웃 게인만 별도로 설정합니다.

**사용법:**
```
W0.05    ← 워시아웃 게인 0.05로 설정
```

**설명:**
- 워시아웃 게인은 짐벌이 중앙 위치로 복귀하는 속도를 제어합니다
- 값이 클수록 빨리 복귀하지만 스쿠터가 흔들릴 수 있습니다
- 기본값: 0.05 (천천히 복귀)

**응답 예시:**
```
LOG: Washout gain set to 0.050
```

---

## 2. 텔레메트리 데이터 형식

### 2.1 통신 설정

**텔레메트리 + HMI 포트**: **UART1** (GPIO 18 TX, 17 RX) — 바이너리 텔레메트리(100Hz)와 HMI 명령 수신/응답(ASCII)을 **같은 포트**에서 처리. 바이너리/ASCII 혼용.  
**속도**: 115200 baud  
**주기**: config.h `TELEMETRY_CYCLE_MS` (기본 10ms = 100Hz)  
**형식**: **바이너리** (110바이트 고정 패킷) + **ASCII** (명령/상태/LOG 줄 단위)

**UART0 (USB)**: **디버그 전용** — printf, ESP_LOG 등 시리얼 모니터용. HMI 명령/응답은 UART1에서만 송수신.

### 2.2 텔레메트리 패킷 (바이너리)

**고정 길이 패킷**을 스트리밍으로 전송합니다.

**패킷 동기:** 매직 2바이트 `0xAA 0x55`로 패킷 시작 검출.  
**바이트 순서:** Little-endian.  
**체크섬:** 마지막 1바이트 = 앞 모든 바이트의 XOR.

| 오프셋 | 크기 | 타입    | 필드 |
|--------|------|---------|------|
| 0      | 2    | uint8[] | magic (0xAA 0x55) |
| 2      | 4    | uint32  | timestamp_ms |
| 6      | 12   | float×3 | roll, pitch, yaw |
| 18     | 12   | float×3 | gyroX, gyroY, gyroZ |
| 30     | 8    | float×2 | accelX, accelY |
| 38     | 4    | int32   | targetRPM |
| 42     | 8    | int32×2 | wheel1_rpm, wheel2_rpm |
| 50     | 8    | float×2 | wheel1_pwm, wheel2_pwm |
| 58     | 1    | uint8   | wheel_state (0=정지, 1=구동, 2=비상) |
| 59     | 12   | float×3 | gimbal_angle, gimbal_target, gimbal_velocity |
| 71     | 8    | float×2 | gimbal1, gimbal2 |
| 79     | 1    | uint8   | balancing (0/1) |
| 80     | 16   | float×4 | balKp, balKi, balKd, washout |
| 96     | 12   | float×3 | wheelKp, wheelKi, wheelKd |
| 108    | 1    | uint8   | comm_bits (bit0=angle, bit1=rpm1, bit2=rpm2, bit3=wheel, bit4=gimbal, bit5=main) |
| 109    | 1    | uint8   | checksum (XOR of bytes 0..108) |

**패킷 길이:** 110 바이트.

### 2.3 텔레메트리 포트 (UART1 — 바이너리/ASCII 혼용)

**UART1(GPIO 18 TX, 17 RX)** 에서 **바이너리 텔레메트리**와 **HMI 응답(ASCII)** 이 함께 전송됩니다. 수신 측에서는 매직 `0xAA 0x55`로 바이너리 패킷을 구분하고, 줄바꿈으로 끝나는 줄은 ASCII(상태/LOG)로 파싱하면 됩니다.

**권장 파싱:** 매직 `0xAA 0x55` 검출 → 110바이트 읽기 → XOR 체크섬 검사. 실패 시 1바이트 진행 후 재동기. 그 외 `\n`으로 끝나는 줄은 ASCII로 처리.

**Python 수신 예시 (UART1 연결, 115200):**
- `COM3`는 **UART1(GPIO 18/17)에 연결한 USB-시리얼 어댑터**의 COM 번호로 바꾸세요. (ESP32를 꽂는 USB 포트와는 다름)
```python
import struct
import serial

PACKET_SIZE = 110
MAGIC = bytes([0xAA, 0x55])

ser = serial.Serial('COM3', 115200)  # UART1에 연결된 USB-시리얼 어댑터 (COM 번호는 환경에 맞게 변경)
buf = b''
while True:
    buf += ser.read(ser.in_waiting or 1)
    while len(buf) >= PACKET_SIZE:
        idx = buf.find(MAGIC)
        if idx < 0:
            buf = buf[-PACKET_SIZE+1:]
            break
        if idx > 0:
            buf = buf[idx:]
        if len(buf) < PACKET_SIZE:
            break
        pkt = buf[:PACKET_SIZE]
        buf = buf[PACKET_SIZE:]
        checksum = 0
        for b in pkt[:-1]:
            checksum ^= b
        if checksum != pkt[-1]:
            continue  # 체크섬 오류 시 스킵 (ASCII 혼합/잘못된 동기 시에도 안전)
        (ts,) = struct.unpack_from('<I', pkt, 2)
        roll, pitch, yaw = struct.unpack_from('<fff', pkt, 6)
        # ... 나머지 필드도 struct.unpack_from('<f', pkt, offset) 등으로 파싱
        print(ts, roll, pitch, yaw)
```

---

## 3. 실제 사용 예시

### 예시 1: 기본 구동

```
# 1. 목표 RPM 설정
R1000

# 2. 구동 시작
S1

# 3. 상태 확인
?

# 4. 정지
S0
```

### 예시 2: 밸런싱 모드

```
# 1. 밸런싱 PID 게인 설정
K5.0,0.1,0.5,0.05

# 2. 밸런싱 모드 시작
B1

# 3. 밸런싱 모드 종료
B0
```

### 예시 3: 비상 정지

```
# 1. 비상 정지
E

# 2. 비상 정지 해제
X

# 3. 다시 구동
S1
```

---

## 4. 안전 주의사항

### ⚠️ 중요 안전 규칙

1. **비상 정지 명령어 (`E`)를 항상 준비하세요**
   - 비상 상황 발생 시 즉시 사용
   - 키보드에서 쉽게 접근할 수 있는 위치에 두세요

2. **구동 전 확인사항**
   - 주변에 사람이나 장애물이 없는지 확인
   - 시스템이 정상 작동하는지 확인 (`?` 명령어로 상태 확인)
   - 비상 정지 해제 상태인지 확인

3. **RPM 설정 주의**
   - 처음 사용 시 낮은 RPM부터 시작 (예: `R500`)
   - 점진적으로 증가시키며 테스트
   - 최대 RPM은 모터 사양을 확인하세요

4. **밸런싱 모드 주의**
   - 밸런싱 모드는 강력한 제어력을 가집니다
   - 처음 사용 시 낮은 게인부터 시작
   - 주변에 충분한 공간 확보

5. **통신 상태 확인**
   - 텔레메트리 패킷의 `comm_bits`(오프셋 108) 확인
   - 통신 오류 시 즉시 정지

---

**마지막 업데이트**: 2026년 1월 30일
